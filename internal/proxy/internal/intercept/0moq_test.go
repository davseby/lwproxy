// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package intercept

import (
	"net"
	"sync"
	"time"
)

// Ensure, that BytesLimiterMock does implement BytesLimiter.
// If this is not the case, regenerate this file with moq.
var _ BytesLimiter = &BytesLimiterMock{}

// BytesLimiterMock is a mock implementation of BytesLimiter.
//
//	func TestSomethingThatUsesBytesLimiter(t *testing.T) {
//
//		// make and configure a mocked BytesLimiter
//		mockedBytesLimiter := &BytesLimiterMock{
//			CheckBytesFunc: func() (bool, error) {
//				panic("mock out the CheckBytes method")
//			},
//			UseBytesFunc: func(n int64) error {
//				panic("mock out the UseBytes method")
//			},
//		}
//
//		// use mockedBytesLimiter in code that requires BytesLimiter
//		// and then make assertions.
//
//	}
type BytesLimiterMock struct {
	// CheckBytesFunc mocks the CheckBytes method.
	CheckBytesFunc func() (bool, error)

	// UseBytesFunc mocks the UseBytes method.
	UseBytesFunc func(n int64) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckBytes holds details about calls to the CheckBytes method.
		CheckBytes []struct {
		}
		// UseBytes holds details about calls to the UseBytes method.
		UseBytes []struct {
			// N is the n argument value.
			N int64
		}
	}
	lockCheckBytes sync.RWMutex
	lockUseBytes   sync.RWMutex
}

// CheckBytes calls CheckBytesFunc.
func (mock *BytesLimiterMock) CheckBytes() (bool, error) {
	callInfo := struct {
	}{}
	mock.lockCheckBytes.Lock()
	mock.calls.CheckBytes = append(mock.calls.CheckBytes, callInfo)
	mock.lockCheckBytes.Unlock()
	if mock.CheckBytesFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.CheckBytesFunc()
}

// CheckBytesCalls gets all the calls that were made to CheckBytes.
// Check the length with:
//
//	len(mockedBytesLimiter.CheckBytesCalls())
func (mock *BytesLimiterMock) CheckBytesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCheckBytes.RLock()
	calls = mock.calls.CheckBytes
	mock.lockCheckBytes.RUnlock()
	return calls
}

// UseBytes calls UseBytesFunc.
func (mock *BytesLimiterMock) UseBytes(n int64) error {
	callInfo := struct {
		N int64
	}{
		N: n,
	}
	mock.lockUseBytes.Lock()
	mock.calls.UseBytes = append(mock.calls.UseBytes, callInfo)
	mock.lockUseBytes.Unlock()
	if mock.UseBytesFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UseBytesFunc(n)
}

// UseBytesCalls gets all the calls that were made to UseBytes.
// Check the length with:
//
//	len(mockedBytesLimiter.UseBytesCalls())
func (mock *BytesLimiterMock) UseBytesCalls() []struct {
	N int64
} {
	var calls []struct {
		N int64
	}
	mock.lockUseBytes.RLock()
	calls = mock.calls.UseBytes
	mock.lockUseBytes.RUnlock()
	return calls
}

// Ensure, that connMock does implement conn.
// If this is not the case, regenerate this file with moq.
var _ conn = &connMock{}

// connMock is a mock implementation of conn.
//
//	func TestSomethingThatUsesconn(t *testing.T) {
//
//		// make and configure a mocked conn
//		mockedconn := &connMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			LocalAddrFunc: func() net.Addr {
//				panic("mock out the LocalAddr method")
//			},
//			ReadFunc: func(b []byte) (int, error) {
//				panic("mock out the Read method")
//			},
//			RemoteAddrFunc: func() net.Addr {
//				panic("mock out the RemoteAddr method")
//			},
//			SetDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetDeadline method")
//			},
//			SetReadDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetReadDeadline method")
//			},
//			SetWriteDeadlineFunc: func(t time.Time) error {
//				panic("mock out the SetWriteDeadline method")
//			},
//			WriteFunc: func(b []byte) (int, error) {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedconn in code that requires conn
//		// and then make assertions.
//
//	}
type connMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// LocalAddrFunc mocks the LocalAddr method.
	LocalAddrFunc func() net.Addr

	// ReadFunc mocks the Read method.
	ReadFunc func(b []byte) (int, error)

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() net.Addr

	// SetDeadlineFunc mocks the SetDeadline method.
	SetDeadlineFunc func(t time.Time) error

	// SetReadDeadlineFunc mocks the SetReadDeadline method.
	SetReadDeadlineFunc func(t time.Time) error

	// SetWriteDeadlineFunc mocks the SetWriteDeadline method.
	SetWriteDeadlineFunc func(t time.Time) error

	// WriteFunc mocks the Write method.
	WriteFunc func(b []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// LocalAddr holds details about calls to the LocalAddr method.
		LocalAddr []struct {
		}
		// Read holds details about calls to the Read method.
		Read []struct {
			// B is the b argument value.
			B []byte
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
		// SetDeadline holds details about calls to the SetDeadline method.
		SetDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// SetReadDeadline holds details about calls to the SetReadDeadline method.
		SetReadDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// SetWriteDeadline holds details about calls to the SetWriteDeadline method.
		SetWriteDeadline []struct {
			// T is the t argument value.
			T time.Time
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// B is the b argument value.
			B []byte
		}
	}
	lockClose            sync.RWMutex
	lockLocalAddr        sync.RWMutex
	lockRead             sync.RWMutex
	lockRemoteAddr       sync.RWMutex
	lockSetDeadline      sync.RWMutex
	lockSetReadDeadline  sync.RWMutex
	lockSetWriteDeadline sync.RWMutex
	lockWrite            sync.RWMutex
}

// Close calls CloseFunc.
func (mock *connMock) Close() error {
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedconn.CloseCalls())
func (mock *connMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// LocalAddr calls LocalAddrFunc.
func (mock *connMock) LocalAddr() net.Addr {
	callInfo := struct {
	}{}
	mock.lockLocalAddr.Lock()
	mock.calls.LocalAddr = append(mock.calls.LocalAddr, callInfo)
	mock.lockLocalAddr.Unlock()
	if mock.LocalAddrFunc == nil {
		var (
			addrOut net.Addr
		)
		return addrOut
	}
	return mock.LocalAddrFunc()
}

// LocalAddrCalls gets all the calls that were made to LocalAddr.
// Check the length with:
//
//	len(mockedconn.LocalAddrCalls())
func (mock *connMock) LocalAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLocalAddr.RLock()
	calls = mock.calls.LocalAddr
	mock.lockLocalAddr.RUnlock()
	return calls
}

// Read calls ReadFunc.
func (mock *connMock) Read(b []byte) (int, error) {
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	if mock.ReadFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.ReadFunc(b)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedconn.ReadCalls())
func (mock *connMock) ReadCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *connMock) RemoteAddr() net.Addr {
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	if mock.RemoteAddrFunc == nil {
		var (
			addrOut net.Addr
		)
		return addrOut
	}
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedconn.RemoteAddrCalls())
func (mock *connMock) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}

// SetDeadline calls SetDeadlineFunc.
func (mock *connMock) SetDeadline(t time.Time) error {
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetDeadline.Lock()
	mock.calls.SetDeadline = append(mock.calls.SetDeadline, callInfo)
	mock.lockSetDeadline.Unlock()
	if mock.SetDeadlineFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetDeadlineFunc(t)
}

// SetDeadlineCalls gets all the calls that were made to SetDeadline.
// Check the length with:
//
//	len(mockedconn.SetDeadlineCalls())
func (mock *connMock) SetDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetDeadline.RLock()
	calls = mock.calls.SetDeadline
	mock.lockSetDeadline.RUnlock()
	return calls
}

// SetReadDeadline calls SetReadDeadlineFunc.
func (mock *connMock) SetReadDeadline(t time.Time) error {
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetReadDeadline.Lock()
	mock.calls.SetReadDeadline = append(mock.calls.SetReadDeadline, callInfo)
	mock.lockSetReadDeadline.Unlock()
	if mock.SetReadDeadlineFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetReadDeadlineFunc(t)
}

// SetReadDeadlineCalls gets all the calls that were made to SetReadDeadline.
// Check the length with:
//
//	len(mockedconn.SetReadDeadlineCalls())
func (mock *connMock) SetReadDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetReadDeadline.RLock()
	calls = mock.calls.SetReadDeadline
	mock.lockSetReadDeadline.RUnlock()
	return calls
}

// SetWriteDeadline calls SetWriteDeadlineFunc.
func (mock *connMock) SetWriteDeadline(t time.Time) error {
	callInfo := struct {
		T time.Time
	}{
		T: t,
	}
	mock.lockSetWriteDeadline.Lock()
	mock.calls.SetWriteDeadline = append(mock.calls.SetWriteDeadline, callInfo)
	mock.lockSetWriteDeadline.Unlock()
	if mock.SetWriteDeadlineFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetWriteDeadlineFunc(t)
}

// SetWriteDeadlineCalls gets all the calls that were made to SetWriteDeadline.
// Check the length with:
//
//	len(mockedconn.SetWriteDeadlineCalls())
func (mock *connMock) SetWriteDeadlineCalls() []struct {
	T time.Time
} {
	var calls []struct {
		T time.Time
	}
	mock.lockSetWriteDeadline.RLock()
	calls = mock.calls.SetWriteDeadline
	mock.lockSetWriteDeadline.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *connMock) Write(b []byte) (int, error) {
	callInfo := struct {
		B []byte
	}{
		B: b,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	if mock.WriteFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.WriteFunc(b)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedconn.WriteCalls())
func (mock *connMock) WriteCalls() []struct {
	B []byte
} {
	var calls []struct {
		B []byte
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}

// Ensure, that listenerMock does implement listener.
// If this is not the case, regenerate this file with moq.
var _ listener = &listenerMock{}

// listenerMock is a mock implementation of listener.
//
//	func TestSomethingThatUseslistener(t *testing.T) {
//
//		// make and configure a mocked listener
//		mockedlistener := &listenerMock{
//			AcceptFunc: func() (net.Conn, error) {
//				panic("mock out the Accept method")
//			},
//			AddrFunc: func() net.Addr {
//				panic("mock out the Addr method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//		}
//
//		// use mockedlistener in code that requires listener
//		// and then make assertions.
//
//	}
type listenerMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func() (net.Conn, error)

	// AddrFunc mocks the Addr method.
	AddrFunc func() net.Addr

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
		}
		// Addr holds details about calls to the Addr method.
		Addr []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
	}
	lockAccept sync.RWMutex
	lockAddr   sync.RWMutex
	lockClose  sync.RWMutex
}

// Accept calls AcceptFunc.
func (mock *listenerMock) Accept() (net.Conn, error) {
	callInfo := struct {
	}{}
	mock.lockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	mock.lockAccept.Unlock()
	if mock.AcceptFunc == nil {
		var (
			connOut net.Conn
			errOut  error
		)
		return connOut, errOut
	}
	return mock.AcceptFunc()
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//
//	len(mockedlistener.AcceptCalls())
func (mock *listenerMock) AcceptCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAccept.RLock()
	calls = mock.calls.Accept
	mock.lockAccept.RUnlock()
	return calls
}

// Addr calls AddrFunc.
func (mock *listenerMock) Addr() net.Addr {
	callInfo := struct {
	}{}
	mock.lockAddr.Lock()
	mock.calls.Addr = append(mock.calls.Addr, callInfo)
	mock.lockAddr.Unlock()
	if mock.AddrFunc == nil {
		var (
			addrOut net.Addr
		)
		return addrOut
	}
	return mock.AddrFunc()
}

// AddrCalls gets all the calls that were made to Addr.
// Check the length with:
//
//	len(mockedlistener.AddrCalls())
func (mock *listenerMock) AddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAddr.RLock()
	calls = mock.calls.Addr
	mock.lockAddr.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *listenerMock) Close() error {
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedlistener.CloseCalls())
func (mock *listenerMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}
